<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	
</body>
<script>
 	function Teacher(name,age){
 		this.name = name;
 		this.age = age;
 	}

 	Teacher.prototype.sayName = function(){
 		console.log('my name is '+this.name + ' and my age is ' + this.age)
 	}



//------------------------------分割线--------------------------------------


 	function Person(name,age){
 		Teacher.call(this,name,age)
 	}

 	Person.prototype = Teacher.prototype; //方法的继承，但是有缺陷:两者prototype.constructor都指向了Teacher,并且继承者的构造函数添加的方法能被被继承者所使用，原则是不允许的

 	//尝试改造：同上，会把父类(被继承者)的prototype.constructor改掉为Person，原则也是不行的
 	// Person.prototype.constructor = Person 

 	var p1 = new Person('jly',18)

 	p1.sayName()

 	console.log(Teacher.prototype)
 	console.log(Person.prototype)

 	Person.prototype.sayAge = function(){
 		console.log('sayAge....')
 	}

 	var t1 = new Person('amy',99)
 	t1.sayAge()
</script>
</html> 